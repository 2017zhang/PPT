<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Collaborative Development&Slides tutorial</title>

    <link rel="stylesheet" href="../css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="../css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="../lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? '../css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
    <style>


    </style>
</head>
<body>
<img src="../img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h3>【CSS-08】margin负值在页面布局中有哪些应用？</h3>
            <h3>小课堂【武汉-143期】</h3>
            <p>分享人：庄引</p>
        </section>
        <section>

            <p>目录</p>
            <div style="text-align:center ;%">
                <p>1.背景介绍</p>
                <p>2.知识剖析</p>
                <p>3.常见问题</p>
                <p>4.解决方案</p>
                <p>5.编码实战</p>
                <p>6.扩展思考</p>
                <p>7.参考文献</p>
                <p>8.更多讨论</p>
            </div>
        </section>
        <section>
            <section>
                <h3>1.背景介绍</h3>
                <div style="text-align:left ; ">
                    <p>CSS中的负边距(negative margin)就是将margin属性的值设为负值，在CSS布局中很多的布局方法都依赖于负边距。
                        三列布局是前端设计中很常见的页面布局方式，三列一般分别是居左的导航，且宽度固定；主列是居中的主要内容，宽度自适应；附加列一般是广告等额外信息，居右且宽度固定。
                        圣杯布局和双飞翼布局都可以实现这种三列布局， 圣杯布局和双飞翼布局是前端工程师必须掌握，
                        因为它既能体现你懂HTML结构又能体现出你对ＤIV+CSS布局的掌握，也能带来带来最好的用户体验。
                    </p>
                </div>
            </section>
        </section>
        <section>
            <section>
                <h3>2.知识剖析:margin是什么?</h3>
                <div style="text-align:left;">
                    <blockquote>外边距属性定义元素周围的空间。通过使用单独的属性，可以对上、右、下、左的外边距进行设置。也可以使用简写的外边距属性同时改变所有的外边距。--W3School
                    </blockquote>
                    <blockquote>设置外边距会在元素外创建额外的"空白"。“空白”通常是指不能放其他元素且父元素背景可见的区域。--CSS权威指南(第三版)P217</blockquote>
                    <blockquote>
                        外边距（margin）。可以设置盒子与相邻元素的间距。--CSS设计指南(第三版)P64
                    </blockquote>
                </div>
            </section>

            <section>
                <div style="text-align:left ;">
                    <h3>margin 取负值 ?</h3>
                    <p>首先必须先理解margin移动的基准点，而margin的值决定移动的方向和数值。
                        margin的参考线有两类，一类是top、left，它们以外元素作为参考线，另一类是right、bottom，它们以自身作为参考线。
                        简单点说就是：当margin-top、margin-left为负值的时候，会把元素上移、左移，同时元素在文档流中的位置也发生相应变化,
                        这点与position:relative的元素设置top、left后元素还占据原来位置不同当margin-bottom、margin-right设为负值的时候，
                        元素本身没有位置变化，后面的元素会上移、左移。
                    </p>
                </div>
            </section>
            <section>
                <div style="text-align:left ; ">
                    <!--<p>下面这张图很直观地解释了margin的移动，。-->
                    <img src="https://pic3.zhimg.com/v2-a7d813afe7ab2c6c4233146609d00dfa_b.png" alt="margin移动的基准点"
                         style="float:left;">
                    红色箭头表示正值时候的移动方向，当margin为负值的时候就反方向移动
                    总地来说，就是当margin-fonttop、left为负值的时候与参考线的距离减少，当margin-right、bottom为负值的时候参考线就向左、上面移动。 </p>
                </div>
            </section>
        </section>
        <section>
            <section>
                <h3>5.编码实战</h3>
            </section>
            <section>
                <p>
                    圣杯布局 是典型的 CSS 布局问题，有着众多的解决方案。如果你不熟悉圣杯布局的历史，这篇文章 能够提供很好的总结，并连接了几个众所周知的解决方案。
                    圣杯布局由页头 (header)，中间部分 (center)，页脚 (footer)，和三栏组成。中间的一栏是主要内容，左边和右边提供如广告、导航的链接。</p>

            </section>
            <section>
                <img src="http://jns.img.bucket.ks3-cn-beijing.ksyun.com/skill/daily/1be2349b-fe7f-4064-b9d8-1b8377a1dcc7.PNG"
                     alt="">
            </section>
            <section>
                <img src="http://jns.img.bucket.ks3-cn-beijing.ksyun.com/skill/daily/09ee4d1e-b09b-4994-ad78-4415e1efffa9.PNG"
                     alt="">
            </section>
            <section>
                原圣杯布局 是典型的 CSS 布局问题
                圣杯布局由页头 (header)，中间部分 (container)，页脚 (footer)，和三栏组成。中间的一栏是主要内容，左边和右边提供如广告、导航的链接。
                两边带有固定宽度中间可以流动（fluid）；
                中间一栏 (主要内容) 在 HTML 源码中应该首先元素出现；
                使用的 HTML 标记尽量少,仅需一个额外的 div 标签
                仅需非常简单的 CSS，带上最少的兼容性补丁
                当页面内容不够满页面时，页脚应固定在底部。
            </section>
            <section>
                <h3>第1步 建立骨架</h3>
                <p>
                    先完成 header, footer 和 container 三个 主要的div</p>
                <pre>
                    <code>
                        <header></header>

                        <div id="container">

                        </div>
                        <footer></footer>
                    </code>
                </pre>
            </section>
            <section>
                <h3>4 多栏等高</h3>
                <p>正如上面所说，有时候我们还希望多栏等高，使页面看起来更美。于是便有了经典的
                    padding-bottom：9999px；margin-bottom：-9999px；先通过padding把盒子扩展到足够高，然后通过margin 负值把它给拉回来，
                    最后父元素设置overflow：hidden隐藏溢出，这样多栏布局中就会以最高栏为其他栏的视觉高度。
                    当然万物没有完美的，这种等高方法的弊端如下：
                    1）当高度超过9999px时候失效，当然一般高度不会超过这个，也可以设置为最大值 32767px（为啥，因为int的最大值就是32767，超过这个数值会以最大值计算）
                    2）无法设置底部边框
                    其他的就不多说了，以后会专门写一篇多栏等高的文章，详细介绍各种方法的利弊，大家按需使用。</p>

            </section>
            <section>
                ​ container 的内边距设置为左右两栏各自的宽度：
                <img src="https://segmentfault.com/image?src=http://alistapart.com/d/holygrail/diagram_01.gif&objectId=1190000004524159&token=41b5bed96346a86e14d5f51d2cfd1755"
                     alt="">
            </section>
            <section>
                <h3>第2步 加入三栏</h3>
                <p>
                    此时我们有了基本框架，可以把三栏加入进去了。
                <pre>
                <code>
                    <header></header>

                    <div id="container">
                       <div id="center" class="column">
                       </div>
                       <div id="left" class="column">
                       </div>
                       <div id="right" class="column">
                       </div>
                    </div>

                    <footer></footer>
                </code>
            </pre>

            </section>
            <section>
                <p>接着我们给每一栏配上合适的宽度，并将它们设为浮动。同时我们需要清除 footer 的上下环境，以免遭跟上面三栏一起浮动。</p>
            </section>
            <section>
                 <pre>
                     <code>
                         #container .column {
                           position: relative;
                           float: left;
                        }

                        #center {
                           width: 100%;
                        }

                        #left {
                           width: 200px;
                           /* LC width */
                           right: 200px;
                           /* LC width */
                           margin-left: -100%;
                        }

                        #right {
                           width: 150px;
                           /* RC width */
                           margin-right: -100%;
                        }

                        footer {
                           clear: both;
                        }
                     </code>
                 </pre>
            </section>

            <section>
                ​中间一栏的 100% 宽是基于它的父容器 container 的宽度而言的，由于 container 设置了内边距，因此中间栏看起来就处在了网页的中间，
                但左右两栏由于排在中间栏的后面，且因空间不够被挤到了中间栏的下面，如下图所示：
                <img src="https://segmentfault.com/image?src=http://alistapart.com/d/holygrail/diagram_02.gif&objectId=1190000004524159&token=3dee3f40248f3b62fa738e5ae7898dbf"
                     alt="">
            </section>
            <section>
                <h3>第3步 把左侧栏放上去</h3>
                中间栏已经就位，剩下的事情就是把左右两栏放上去了，接下来我们先放左侧栏。

                首先，我们先将它的外边距设置为 -100%，这样一来，
                由于浮动的关系，左侧栏就能上位，与中间栏交叠在一起，并占据了左边。而右侧栏由于左侧栏的上位，自动向前浮动到了原来左侧栏的位置。
                <img src="https://segmentfault.com/image?src=http://alistapart.com/d/holygrail/diagram_03.gif&objectId=1190000004524159&token=be9da59e2a05133fd5d697e707a21c98"
                     alt="">
            </section>
            <section>
                接着我们要用到相对定位属性（relative），并设置一个与左侧栏等宽的偏移量：
                <pre>
                    <code>
                        #container .column {
                           position: relative;
                           float: left;
                        }

                        #left {
                           width: 200px;
                           /* LC width */
                           right: 200px;
                           /* LC width */
                           margin-left: -100%;
                        }
                    </code>
                </pre>
            </section>
            <section>
                可以看到，它设置的 right 属性就是相对于 container 的右边线向左偏移 200px，如此一来，它就完美地跑到了 container 左内边距的位置，也就是我们希望它呆的地方，如下图所示：
                <img src="https://segmentfault.com/image?src=http://alistapart.com/d/holygrail/diagram_04.gif&objectId=1190000004524159&token=ad164e0de18d97a1d528e41cabd95adf"
                     alt="">
            </section>
            <section>
                <h3> 第4步 把右侧栏放上去
                </h3>
                最后，我们需要把右侧栏放上去，此时只需利用上面的原理把他放到 container 的右外边距的位置即可，我们需要再一次设置一个负外边距的值，它等于右侧栏的宽度：
                <pre>
                    <code>
                        ​#right {
                            width: 150px;
                           /* RC width */
                           margin-right: -100%;
                        }
                    </code>
                </pre>
            </section>
            <section>
                至此，所有的栏目都就位了~
                <img src="https://segmentfault.com/image?src=http://alistapart.com/d/holygrail/diagram_05.gif&objectId=1190000004524159&token=e3824f9bfc1fa952292cc9ae8efd2221"
                     alt="">
            </section>
        </section>

        <section>
            <section>
                <h3>6.扩展思考</h3>
                <div style="text-align:left;">
                当浏览器缩小到一定程度时，这个布局可能会被破坏,怎么解决?
                可以在body上添加min-width属性解决
                圣杯布局其实和双飞翼布局是什么关系?
                事实上，圣杯布局其实和双飞翼布局是一回事。它们实现的都是三栏布局，两边的盒子宽度固定，中间盒子自适应。它们实现的效果是一样的，差别在于其实现思想。
                圣杯布局的优点?

                <li>使主要内容列优先加载。</li>
                <li>允许任何列是最高的。</li>
                <li>没有额外的div,简洁明了。</li>
                <li>需要的hack很少。</li>
                </div>
            </section>
            <section>
                <div style="text-align:left;">
                    双飞翼布局的优点： 双飞翼布局非常灵活，通过调整css代码可以实现各种布局。例如，利用双飞翼布局实现了一套栅格布局系统。
                    <li>DOM按照主、子、附加列的顺序加载，实现了重要内容先加载。</li>
                    <li>main部分是自适应宽度的，易在定宽布局和流体布局中切换。</li>
                    <li>在浏览器上的兼容性非常好，</li>
                    <li> 实现了内容与布局的分离</li>
                    <li>任何一栏都可以是最高栏，不会出问题。</li>
                    <li>需要的hack非常少。</li>
                </div>
            </section>
        </section>

        <section>
            <h3>7.参考文献</h3>
            <li><a href="https://segmentfault.com/a/1190000004524159">(2)关于「圣杯布局」 - 天道酬勤 - SegmentFault</a></li>
            <li><a href="http://www.jianshu.com/p/f9bcddb0e8b4">圣杯布局和双飞翼布局（前端面试必看） - 简书</a></li>
            <li>            <a href="https://theqwang.github.io/2016/01/08/%E6%B5%85%E6%9E%90%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/">浅析圣杯布局和双飞翼布局 | theqwang'blog</a>
            </li>

        </section>

        <section>
            <h3>8.更多思考:</h3>
            <div style="text-align:left">
                圣杯布局与双飞翼布局在实现上的异同点：
                <li>两种布局方式都是把主列放在文档流最前面，使主列优先加载。</li>
                <li>两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。</li>
                两种布局方式的不同之处在于如何处理中间主列的位置：圣杯布局是利用父容器的左、右内边距定位；双飞翼布局是把主列嵌套在div后利用主列的左、右外边距定位。</li>
                <li>两者相比较，双飞翼布局虽然多了一个div，却减少了相对定位属性的代码，个人认为双飞翼布局在实现思路和代码简洁度上都要比圣杯布局更好一些。</li>

            </div>
        </section>
    </div>
</div>

<script src="../lib/reveal/js/head.min.js"></script>
<script src="../lib/reveal/reveal.js"></script>

<script>

    // 以下为常见配置属性的默认值
    // {
    // 	controls: true, // 是否在右下角展示控制条
    // 	progress: true, // 是否显示演示的进度条
    // 	slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    // 	history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    // 	keyboard: true, // 是否启用键盘快捷键来导航
    // 	overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    // 	center: true, // 是否将幻灯片垂直居中
    // 	touch: true, // 是否在触屏设备上启用触摸滑动切换
    // 	loop: false, // 是否循环演示
    // 	rtl: false, // 是否将演示的方向变成RTL，即从右往左
    // 	fragments: true, // 全局开启和关闭碎片。
    // 	autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    // 	transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    // 	transitionSpeed: 'default', // 过渡速度，default/fast/slow
    // 	mouseWheel: false, //是否启用通过鼠标滚轮来切换幻灯片
    // }

    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        transition: 'convex',


        dependencies: [
            {src: '../plugin/markdown/marked.js'},
            {src: '../plugin/markdown/markdown.js'},
            {src: '../plugin/notes/notes.js', async: true},
            {
                src: '../plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            }
        ]
    });
</script>
</body>
</html>
